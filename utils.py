from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib.utils import ImageReader
from PIL import Image
import io
import os
import pandas as pd
from datetime import datetime
try:
    # optional: load .env if present
    from dotenv import load_dotenv
    load_dotenv()
except Exception:
    pass


def generate_proof_pdf(file_bytes: bytes, filename: str, task_description: str, log_path: str = "proof_log.csv") -> bytes:
    """Generate a proof PDF from image bytes and log the entry.

    Returns PDF bytes.
    """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    pdf_buffer = io.BytesIO()
    c = canvas.Canvas(pdf_buffer, pagesize=letter)
    page_width, page_height = letter
    margin = 50
    y = page_height - margin

    c.setFont("Helvetica-Bold", 16)
    c.drawString(margin, y, "SnapProof – Timestamped Proof")
    c.setFont("Helvetica", 11)
    y -= 30
    c.drawString(margin, y, f"Task: {task_description}")
    y -= 18
    c.drawString(margin, y, f"Timestamp: {timestamp}")
    y -= 18
    c.drawString(margin, y, f"Filename: {filename}")
    y -= 24

    try:
        img = Image.open(io.BytesIO(file_bytes)).convert("RGB")
        img_w, img_h = img.size

        max_w = page_width - 2 * margin
        max_h = 300
        scale = min(max_w / img_w, max_h / img_h, 1.0)
        draw_w = img_w * scale
        draw_h = img_h * scale

        img_reader = ImageReader(img)
        c.drawImage(img_reader, margin, y - draw_h, width=draw_w, height=draw_h)
        y -= draw_h + 20
    except Exception as e:
        y -= 10
        c.setFont("Helvetica-Oblique", 10)
        c.drawString(margin, y, f"(Could not embed image: {e})")
        y -= 12

    c.setFont("Helvetica", 9)
    c.drawString(margin, 40, "Generated by SnapProof")

    c.showPage()
    c.save()
    pdf_buffer.seek(0)
    pdf_bytes = pdf_buffer.getvalue()

    # Attempt Google Sheets logging if enabled, otherwise fall back to CSV
    entry = {"timestamp": timestamp, "task": task_description, "filename": filename}
    use_sheets = os.getenv("USE_SHEETS", "false").lower() in ("1", "true", "yes")
    if use_sheets:
        try:
            log_to_sheets(entry)
        except Exception:
            # if sheets logging fails, fall back to CSV
            try:
                if os.path.exists(log_path):
                    df = pd.read_csv(log_path)
                    df = pd.concat([df, pd.DataFrame([entry])], ignore_index=True)
                else:
                    df = pd.DataFrame([entry])
                df.to_csv(log_path, index=False)
            except Exception:
                pass
    else:
        try:
            if os.path.exists(log_path):
                df = pd.read_csv(log_path)
                df = pd.concat([df, pd.DataFrame([entry])], ignore_index=True)
            else:
                df = pd.DataFrame([entry])
            df.to_csv(log_path, index=False)
        except Exception:
            # If logging fails, ignore but do not break PDF generation
            pass

    return pdf_bytes


def log_to_sheets(entry: dict, sheet_id: str = None, sheet_name: str = "Sheet1", creds_path: str = None) -> bool:
    """Append an entry (dict with keys timestamp, task, filename) to a Google Sheet.

    Environment variables used when parameters are omitted:
      - GOOGLE_CREDENTIALS: path to service account JSON (default: credentials.json)
      - GOOGLE_SHEETS_ID: spreadsheet ID (from its URL)

    Returns True on success, raises on failure.
    """
    try:
        import gspread
        from oauth2client.service_account import ServiceAccountCredentials
    except Exception as e:
        raise RuntimeError("gspread and oauth2client are required for Google Sheets logging") from e

    if creds_path is None:
        creds_path = os.getenv("GOOGLE_CREDENTIALS", "credentials.json")
    if sheet_id is None:
        sheet_id = os.getenv("GOOGLE_SHEETS_ID")
    if not sheet_id:
        raise ValueError("Google Sheets ID not provided. Set GOOGLE_SHEETS_ID env var or pass sheet_id")

    scope = [
        "https://www.googleapis.com/auth/spreadsheets",
        "https://www.googleapis.com/auth/drive",
    ]
    creds = ServiceAccountCredentials.from_json_keyfile_name(creds_path, scope)
    gc = gspread.authorize(creds)

    # Open spreadsheet and worksheet
    sh = gc.open_by_key(sheet_id)
    try:
        worksheet = sh.worksheet(sheet_name)
    except Exception:
        worksheet = sh.add_worksheet(title=sheet_name, rows="1000", cols="10")

    row = [entry.get("timestamp", ""), entry.get("task", ""), entry.get("filename", "")]
    worksheet.append_row(row, value_input_option="USER_ENTERED")
    return True


def generate_multipage_proof_pdf(photos: list, statement: str, photo_comments: dict = None) -> bytes:
    """Generate a multi-page PDF containing a statement and a page per photo.

    photos: list of dicts with keys 'bytes' and 'filename'
    statement: user statement text
    Returns PDF bytes.
    """
    # Use ReportLab platypus to support anchors and internal links
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image as RLImage, PageBreak
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.platypus.flowables import AnchorFlowable

    photo_comments = photo_comments or {}

    pdf_buffer = io.BytesIO()
    doc = SimpleDocTemplate(pdf_buffer, pagesize=letter,
                            rightMargin=50, leftMargin=50, topMargin=50, bottomMargin=50)
    styles = getSampleStyleSheet()
    normal = styles['Normal']
    h1 = ParagraphStyle('h1', parent=styles['Heading1'], fontName='Helvetica-Bold', fontSize=16)
    link_style = ParagraphStyle('link', parent=normal, textColor='blue', underline=True)

    story = []

    # Build statement page: replace "Photo N" or "Picture N" with internal links
    import re

    def replace_photo_refs(text: str) -> str:
        # replace occurrences like Photo 1 or Picture 2 with an internal link to #photo_1
        def _repl(m):
            kind = m.group(1)
            num = m.group(2)
            anchor = f"photo_{num}"
            return f'<a href="#{anchor}">{kind} {num}</a>'
        return re.sub(r"\b(Photo|Picture)\s+(\d+)\b", _repl, text, flags=re.IGNORECASE)

    story.append(Paragraph("SnapProof – Statement", h1))
    story.append(Spacer(1, 12))
    # Convert statement to paragraphs, applying replacements
    for line in statement.splitlines():
        linked = replace_photo_refs(line)
        story.append(Paragraph(linked, normal))
        story.append(Spacer(1, 6))

    story.append(PageBreak())

    # One page per photo with anchor and optional comment
    for idx, p in enumerate(photos):
        # anchor name
        anchor_name = f"photo_{idx+1}"
        story.append(AnchorFlowable(anchor_name))
        # label
        label = f"Photo {idx+1}: {p.get('filename','')}"
        timestamp = p.get('timestamp', '')
        if timestamp:
            label = f"{label} — {timestamp}"
        story.append(Paragraph(label, styles['Heading3']))
        story.append(Spacer(1, 6))

        try:
            img_buf = io.BytesIO(p['bytes'])
            rl_img = RLImage(img_buf)
            # scale image to fit width
            max_w = letter[0] - doc.leftMargin - doc.rightMargin
            if rl_img.drawWidth > max_w:
                rl_img.drawHeight = rl_img.drawHeight * (max_w / rl_img.drawWidth)
                rl_img.drawWidth = max_w
            story.append(rl_img)
            story.append(Spacer(1, 6))
        except Exception:
            story.append(Paragraph("(Could not embed image)", normal))

        # photo comment
        comment = photo_comments.get(str(idx)) or photo_comments.get(idx) or ''
        if comment:
            story.append(Paragraph(f"<b>Comment:</b> {comment}", normal))
            story.append(Spacer(1, 6))

        story.append(PageBreak())

    doc.build(story)
    pdf_buffer.seek(0)
    return pdf_buffer.getvalue()
